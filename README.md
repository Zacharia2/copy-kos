# 元序列笔记 和 树图知识结构

> 元数据根序列笔记，借鉴Linux的根目录概念。归纳整理所有笔记的元信息或规则。
>
> 分离内容和架构。面向内容，分离数据和软件，不把内容当处理对象的研究软件都是玩软件和新鲜感罢了。

## [树图知识结构](./GrowthK2S)

![tree](./Attachment/c6341a3b82cbba841ff6d1bf3a5074d9.jpg)

Zettelkasten(Slip-box)，太厉害了，我这个小玩具根本比不上。

树 = 层级结构 = 层级列表（嵌套列表）

树结构是最简单实用的存储方式。星系、行政地图。用树去承载图是一个好想法

根到叶子和节点的路径、全部叶子和节点 就是 所有的文件（笔记、元素）、叶子（节点）之间的连接就是图或者别的数据结构。

树结构，缺点是只能从根到叶子。而地图，却是可以从任意一点开始。叶子到根的路径，就是检索的第一类型的难关。地图上的路径实在太美妙了，路径在一段时期存在，路径可以去往任意的地方。

可以通过一个切入点（已有的文章）引发大脑联想，然后这些联想可以聚族，产生新的意义。

真正的内容在卢曼的脑子里，卡片不是知识的载体，而是起到提示作用！卡片并不是在减轻工作记忆，而是在激活知识网络的不同部分产生更多的想法和发现。

关于 idea（想法）映射到任意一颗树的某个节点的问题（索引）的四种可能性：
1. 知道内容，并且知道文件名，直接检索文件名
2. 知道内容，但不知道文件名，不过可以通过推断出类型，然后查找路径后找到。
3. 知道内容，但无法推断出类型，可以通过内容推断大致类型，然后模糊匹配。
4. 不知道内容，只有感觉，通过感觉描述。借助ai吧。或者优化节点和叶子。

关于快速检索：
1. 可以为自己的知识库绘制堪舆图，利用Mapping:Moc、Mapping:Graph。
2. 通过线索索引目标、
3. 检索就是过滤，不断缩小笔记的数量。正如标签做的那个样子。

关于叶子和节点：
1. 叶子也有好叶子和坏叶子。
	1. 好叶子就是你记得名字，和大部分内容。或者别的。
2. 好叶子应该给与优先级，坏叶子应该给予概率。

关于笔记的功能：
1. 笔记＝复用➕快速索引，笔记不能代替自己的大脑思考，笔记只能是我们大脑记忆的延伸。也就是辅助记忆的工具。
2. 复用（写入和读取）笔记的读和写操作。查询优化。
	1. 内化的辅助工具
	2. 记忆的辅助工具
3. 启发性
4. 记录思考过程
5. 快速检索
6. 笔记就是一个外置存储器，关注速度和检索就好了
7. 相互连接笔记、写自己的想法

关于笔记的作用：
1. 帮助我们存储信息
2. 帮助我们思考和理解信息
3. 创造知识与知识之间的链接

关于笔记的层次：
1. 笔记的内容的记载（笔记的包含）
2. 笔记本身以及笔记的定义属性或字段（笔记的本身）
3. 笔记的组织索引。（多笔记的组织索引）
4. 树的组织

此结构是一种为了实现：将单条笔记放入结构体系中，可以快速检索到它的解决方案。检索和结构密切相关。同时也是为了增加其它的功能，比如笔记之间的边关系的处理等等。然后也逐渐认识笔记的本质是什么——辅助记忆和学习的工具。是我对PKM知识的不断实践、认知和发展的过程。

想法（写作和思考）的生成树、概念层次结构树、节点之间的相互关系、节点的类型定义、关于节点自己、节点组合产生的系统效果。

ZK2的编码，若有内容树一般的树形文件结构（无文件夹），则可以使用内容树实现。无需特定规则编码，直接使用任意ID即可。

## “当我想找一篇文章，它一定在这里。”

> 软件多少是伪命题，真相在集中存储 
>
> 关于All in one还是什么N+1的争论一直没停下过。 
>
> 但实际上这不是问题，问题是：你必须能在一个地方，尽可能找到你储存的全部信息。 
>
> “当我想找一篇文章，它一定在这里。” 
>
> 有这种感觉就够了。


## 正文

1. 分而治之：将每个软件都纳入工作流程的一部分，每一个软件承担各种的流程。收集的软件就承担收集工作，整理软件就承担整理工作。整理软件就承担整理工作。
    小米笔记（时间序列）、印象笔记（同步）  、 OneNote 、 obsidian、Tiddlywiki。

2. 剪藏&创作，使用是否为自己书写简单区分为这两类。

## 多样性

1. 概念专用名词解释
2. 说明文。

## 盖尔定律

### 定义

"All complex systems that work evolved from simpler systems that worked. [And conversely...] A complex system designed from scratch never works and cannot be patched up to make it work."

所有切实可行的复杂系统势必是从切实可行的简单系统发展而来的。一个一开始就设计复杂系统永远无法运行，也无法通过修补使其工作。你必须从一个简单的系统开始。

盖尔定律说明了设计高度复杂的系统很可能会失败。它们很难一蹴而就，更多的是从简单的系统逐渐演变而来。

#### 阐述

仔细观察可以发现，无论是一个互联网软件系统的架构，还是一个城市的建设，载人航天飞机的建造，都不是一开始就事无巨细设计好的，没有任何人可以模拟真实场景中的各种内外部因素，也就是说在一个系统逐步成熟和复杂化的过程中，是不断对外部无数变量进行响应和调整的过程。

---

## 附加

**元数据**（英语：metadata）又称**元资料**、**诠释资料**、**后设资料**、**中继资料**、**中介资料**等等，为描述其他[资料](https://zh.wikipedia.org/wiki/資料)[信息](https://zh.wikipedia.org/wiki/資訊)的资料。

**反射**是指[计算机程序](https://baike.baidu.com/item/计算机程序?fromModule=lemma_inlink)在[运行时](https://baike.baidu.com/item/运行时?fromModule=lemma_inlink)（Run time）可以访问、检测和修改它本身状态或行为的一种能力。

**元知识**（英语：metaknowledge）是关于描述、使用一般[知识](https://zh.wikipedia.org/wiki/知识)的知识[[1]](https://zh.wikipedia.org/wiki/元知识#cite_note-陈-1)。元知识常被宽泛地依照字面意思称为“关于知识的知识”。

**元对象**（metaobject）是操纵、创建、描述或实现对象（包括自身）的[对象](https://zh.wikipedia.org/wiki/对象_(计算机科学))。适用于元对象的对象叫做基础对象。元对象可以定义的一些信息包括：基础对象的[类型](https://zh.wikipedia.org/wiki/类型系统)、[接口](https://zh.wikipedia.org/wiki/接口_(计算机科学))、[类](https://zh.wikipedia.org/wiki/类_(计算机科学))、[方法](https://zh.wikipedia.org/wiki/方法_(计算机科学))、[特性](https://zh.wikipedia.org/wiki/特性_(计算机科学))、[解析树](https://zh.wikipedia.org/wiki/解析树)等。元对象是计算机科学[反射](https://zh.wikipedia.org/wiki/反射_(计算机科学))概念的例子，这里的系统（通常在运行时间）能访问它自己的内部结构。反射在根本上确使一个系统能现场重写自身，在其运行时改变自己的实现。

## 许可证

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。
